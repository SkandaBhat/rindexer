name: Edit Existing GitHub Releases (One-Time)

on:
  workflow_dispatch:
    inputs:
      start_version:
        description: 'Start editing from this version (e.g., 0.1.0)'
        required: false
        default: '0.1.0' # Adjust this to the earliest version you want to edit
      end_version:
        description: 'End editing at this version (e.g., 0.21.0). Leave empty for all versions from start_version.'
        required: false
        default: '' # Leave empty to process all versions from start_version onwards
      changelog_commit_ref:
        description: 'Commit hash or branch where the full changelog.mdx exists (e.g., master or a specific hash). Defaults to current ref.'
        required: false
        # IMPORTANT: Use the commit hash where your changelog.mdx has all the correct release notes.
        # If your 'master' branch has the complete changelog, 'master' is fine.
        # If the files were at a specific older commit, use that hash (e.g., '96ead5ee413f83fc58796f1661791122cf1a7f60')
        default: 'master' # Change this if your full changelog is on a different branch or specific commit

jobs:
  edit_releases:
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    steps:
      - name: Checkout repository (for changelog)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.changelog_commit_ref }}
          fetch-depth: 0 # Get full history for accurate changelog parsing

      - name: Install GitHub CLI
        run: |
          sudo apt-get update
          sudo apt-get install -y gh

      - name: Set up Node.js for Changelog Parsing
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create release body parser script
        id: create_parser_script
        run: |
          cat << 'EOF' > parse_changelog.js
          const fs = require('fs');
          const path = require('path');

          const changelogPath = path.join(process.env.GITHUB_WORKSPACE, 'documentation', 'docs', 'pages', 'docs', 'changelog.mdx');
          const rawVersion = process.argv[2]; // Version string passed (e.g., "0.1.0", "0.21.0")

          let headerToMatch = '';
          if (rawVersion === '0.1.0') {
            headerToMatch = `# ${rawVersion}`;
          } else {
            headerToMatch = `# ${rawVersion}-beta`;
          }

          console.log(`Attempting to parse changelog for header: "${headerToMatch}"`);

          let releaseNotes = "No specific features/bug fixes mentioned in changelog.";

          try {
            const changelogContent = fs.readFileSync(changelogPath, 'utf8');
            const releasesSection = changelogContent.split(/^## Releases/m)[1];
            if (!releasesSection) {
              console.error("Could not find '## Releases' section in changelog.");
              // This error means the file structure is wrong, but we should still
              // output something to the workflow command file to avoid script breakage.
              // We'll proceed with default notes if this happens.
            } else {
              const releasePattern = new RegExp(`^${headerToMatch}\\s*-\\s*\\d+(?:st|nd|rd|th) \\w+ \\d{4}([\\s\\S]*?)(?:\\n# \\d+\\.\\d+\\.\\d+|$|^## |$)`, 'm');
              const match = releasesSection.match(releasePattern);

              if (match && match[1]) {
                  releaseNotes = match[1].trim();
                  releaseNotes = releaseNotes
                    .replace(/^(github branch - https:\/\/github\.com\/joshstevens19\/rindexer\/tree\/release\/.*)$/gm, '')
                    .replace(/^- (linux|mac|windows) binary - https:\/\/(github|rindexer\.xyz).*$/gm, '')
                    .replace(/^### Features\n-------------------------------------------------$/gm, '### Features')
                    .replace(/^### Bug fixes\n-------------------------------------------------$/gm, '### Bug fixes')
                    .replace(/^### Breaking changes\n-------------------------------------------------$/gm, '### Breaking changes')
                    .replace(/^-+\s*$/gm, '')
                    .replace(/^\s*[\r\n]+/gm, '')
                    .trim();

                   if (releaseNotes === '') {
                     releaseNotes = "No specific features/bug fixes mentioned in changelog.";
                   }
              }
            }
          } catch (error) {
            console.error(`Error reading or parsing changelog: ${error.message}`);
            // Still proceed with default notes if file cannot be read
          }

          // Write the output to GITHUB_OUTPUT environment file
          // This is the correct way to set multiline outputs from scripts
          // without them appearing in stdout capture.
          fs.writeFileSync(process.env.GITHUB_OUTPUT, `release_body<<EOF_DELIMITER\n${releaseNotes}\nEOF_DELIMITER\n`, { flag: 'a' });

          EOF
          chmod +x parse_changelog.js

      - name: Get all existing release tags
        id: get_tags
        run: |
          ALL_TAGS=$(gh api --paginate "/repos/${{ github.repository }}/tags" --jq '.[].name' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sed 's/^v//' | sort -V | paste -sd ' ' -)
          echo "Found tags: $ALL_TAGS"
          echo "all_versions=$ALL_TAGS" >> $GITHUB_OUTPUT

      - name: Edit Releases
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          START_VERSION: ${{ github.event.inputs.start_version }}
          END_VERSION: ${{ github.event.inputs.end_version }}
        run: |
          #!/bin/bash
          set -e

          ALL_VERSIONS="${{ steps.get_tags.outputs.all_versions }}"

          # Filter versions based on optional inputs
          FILTERED_VERSIONS=""

          version_ge() {
            local v1="$1"
            local v2="$2"
            [[ "$v1" = "$v2" ]] || [[ "$(printf '%s\n' "$v1" "$v2" | sort -V | head -n1)" = "$v2" ]]
          }
          version_le() {
            local v1="$1"
            local v2="$2"
            [[ "$v1" = "$v2" ]] || [[ "$(printf '%s\n' "$v1" "$v2" | sort -V | tail -n1)" = "$v2" ]]
          }

          for ver in $ALL_VERSIONS; do
            if [[ -n "$START_VERSION" ]]; then
              if ! version_ge "$ver" "$START_VERSION"; then
                continue
              fi
            fi

            if [[ -n "$END_VERSION" ]]; then
              if ! version_le "$ver" "$END_VERSION"; then
                continue
              fi
            fi

            FILTERED_VERSIONS+=" $ver"
          done

          if [ -z "$FILTERED_VERSIONS" ]; then
            echo "No versions to edit after applying filters. Exiting."
            exit 0
          fi

          echo "Editing versions: $FILTERED_VERSIONS"

          for VERSION in $FILTERED_VERSIONS; do
              echo "--- Processing version: $VERSION ---"

              TAG="v$VERSION"

              # Corrected INSTALL_INSTRUCTIONS block
              INSTALL_INSTRUCTIONS="# Latest version
            curl -L https://rindexer.xyz/install.sh | bash
            # Specific version  
            curl -L https://rindexer.xyz/install.sh | bash -s -- --version $VERSION"
            
            # Call Node.js script to get release body.
            # Capture its stdout, but the actual output is now written to GITHUB_OUTPUT
            node parse_changelog.js "$VERSION"
            
            # Read the output from the GITHUB_OUTPUT file
            # This uses 'sed' to extract the content between the delimiters
            CLEANED_CHANGELOG_BODY=$(sed -n '/^release_body<<EOF_DELIMITER$/,/^EOF_DELIMITER$/{/^release_body<<EOF_DELIMITER$/! {/^EOF_DELIMITER$/! p}}' "$GITHUB_OUTPUT" | head -n 1) # Capture only the content
          
          # Combine all parts for the full release body
          # Format the final body using markdown code blocks
          FULL_RELEASE_BODY="${INSTALL_INSTRUCTIONS}\n\n${CLEANED_CHANGELOG_BODY}\n\nSee full changelog for details: https://github.com/joshstevens19/rindexer/blob/master/documentation/docs/pages/docs/changelog.mdx"
            
            
            echo "Attempting to edit release $TAG..."
            gh release edit "$TAG" \
            --prerelease=false \
            --notes "$FULL_RELEASE_BODY" \
            --target master
            
            echo "Successfully edited release $TAG."
            done